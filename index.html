<!doctype html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <title>Black White</title>
    <script src="//localhost:8000/dist/phaser-arcade-physics.min.js"></script>
    <style type="text/css">
        body {
            margin: 0;
            background: grey;
        }
    </style>
</head>
<body>

<script type="text/javascript">

    // Input
    var mouseX=0;
    var mouseY=0;
    // Sizes
    var pathWidth = 8;
    var followerSize = pathWidth * 2;
    // Geometry
    var bRect;
    var wRect;
    var left;
    var right;
    // Graphics
    var pathGraphics;
    var bGraphics;
    var wGraphics
    // Game objects
    var stars;
    var towers;
    var bullets;

    class PathFollower extends Phaser.Physics.Arcade.Sprite
    {

        constructor (scene, x, y, path, speed)
        {
            super(scene, x, y, 'star');
            // Phaser.Physics.Arcade.Sprite.call(this, scene, x, y, 'star');

            //  This is the path the sprite will follow
            this.path = path
            this.pathVector = new Phaser.Math.Vector2();
            this.pathSpeed = speed;
            this.pathIndex = 0;

            this.path.getPoint(0, this.pathVector);

            this.setPosition(this.pathVector.x, this.pathVector.y);
        }

        preUpdate (time, delta)
        {
            this.anims.update(time, delta);

            this.setAngle(this.angle + 0.25 * delta);

            this.path.getPoint(this.pathIndex, this.pathVector);

            this.setPosition(this.pathVector.x, this.pathVector.y);

            //this.pathIndex = Phaser.Math.Wrap(this.pathIndex + this.pathSpeed, 0, 1);
            this.pathIndex = this.pathIndex + this.pathSpeed;

            if(this.pathIndex > 1) {
                this.setActive(false);
                this.setVisible(false);
                this.pathIndex = 0;
                this.path.getPoint(0, this.pathVector);
                this.setPosition(this.pathVector.x, this.pathVector.y);
            }
        }


        hit ()
        {
            this.setVisible(false);
            this.setActive(false);
            this.pathIndex=0;
            this.path.getPoint(0, this.pathVector);
            this.setPosition(this.pathVector.x, this.pathVector.y);
        }
    }

    class Tower extends Phaser.Physics.Arcade.Sprite
    {
        constructor (scene, x, y)
        {
            super(scene, x, y, 'tower');
            this.setPosition(x, y);
            this.reload=1;
            this.chargeRate=0.015;
        }

        setup (x,y)
        {
            this.setActive(true);
            this.setVisible(true);
            this.setPosition(x, y);
            this.reload=1;
            this.chargeRate=0.015;
        }

        preUpdate (time, delta)
        {
            this.anims.update(time, delta);

            var starsArray = stars.getMatching('active', true);
            var minDist = Phaser.Math.MAX_SAFE_INTEGER;
            var closest = null;
            for( var i in starsArray ) {
                var dist = Phaser.Math.Distance.Between(starsArray[i].x, starsArray[i].y, this.x, this.y);
                if( dist < minDist ) {
                    closest = starsArray[i];
                    minDist = dist
                }
            }

            if( closest ) {
                // rotate to face closest star
                var angleDeg = Math.atan2(this.y - closest.y, this.x - closest.x) * 180 / Math.PI;

                // rotate a certain speed towards closest star
                var stepMax = 4;
                if( angleDeg > this.angle ) {
                    var step = Math.min( angleDeg - this.angle, stepMax );
                    this.setAngle( this.angle + step );
                } else if( angleDeg < this.angle ) {
                    var step = Math.min( this.angle - angleDeg, stepMax );
                    this.setAngle( this.angle - step );
                }

                // fire bullet?
                if( this.reload >= 1 ) {
                    this.reload = 0;
                    // TODO figre out different angle issue
                    var angle = Phaser.Math.Angle.BetweenPoints(this, closest)
                    angle = Phaser.Math.Angle.RotateTo(this.angle, angle, 0.05) ;
                    bullets.fireBullet(this.x, this.y, angle);
                } else {
                    this.reload = this.reload + this.chargeRate;
                }
            } else {
                // rotate in place
                this.setAngle(this.angle + 0.25 * delta);
            }


        }
    }

    class Towers extends Phaser.Physics.Arcade.Group
    {
        constructor (scene)
        {
            super(scene.physics.world, scene);

            this.createMultiple({
                frameQuantity: 4,
                key: 'tower',
                active: false,
                visible: false,
                classType: Tower
            });
        }

        createTower (x, y)
        {
            let tower = this.getFirstDead(false);

            if (tower)
            {
                tower.setup(x, y);
            }
        }
    }

    class Bullet extends Phaser.Physics.Arcade.Sprite
    {
        constructor (scene, x, y)
        {
            super(scene, x, y, 'bullet');
            this.physics = scene.physics
        }

        fire (x, y, angle)
        {
            this.body.reset(x, y);

            this.setActive(true);
            this.setVisible(true);

            this.physics.velocityFromRotation(angle, 600, this.body.velocity);
            this.setAngle(angle);
        }

        preUpdate (time, delta)
        {
            super.preUpdate(time, delta);

            if (this.x < -32 || this.x > 832 || this.y < -32 || this.y > 632)
            {
                this.setActive(false);
                this.setVisible(false);
            }
        }

        hit()
        {
            this.setVelocity(0,0);
            this.x = -32;
            this.y = -32;
            this.body.reset(this.x, this.y);
            this.setVisible(false);
            this.setActive(false);
        }
    }

    class Bullets extends Phaser.Physics.Arcade.Group
    {
        constructor (scene)
        {
            super(scene.physics.world, scene);

            this.createMultiple({
                frameQuantity: 10,
                key: 'bullet',
                active: false,
                visible: false,
                classType: Bullet
            });
        }

        fireBullet (x, y, angle)
        {
            let bullet = this.getFirstDead(false);

            if (bullet)
            {
                bullet.fire(x, y, angle);
            }
        }
    }


    function preload ()
    {
        this.load.image('star', 'assets/star.png');
        this.load.image('tower', 'assets/tower.png');
        this.load.image('bullet', 'assets/bullet.png');
    }


    function create ()
    {
        this.input.on('pointermove', function (pointer) {
            mouseX=pointer.x;
            mouseY=pointer.y;
        });

        this.input.on('pointerdown', function (pointer) {
            console.log('down');
            towers.createTower(pointer.x, pointer.y);
        }, this);


        // White Half
        wGraphics = this.add.graphics({
            lineStyle: { width: 2, color: 0xFFFFFF },
            fillStyle: { color: 0xFFFFFF }
        });
        wRect = new Phaser.Geom.Rectangle(401,0,400,600);
        right = wRect;
        wGraphics.fillRectShape(right);

        // Black Half
        bGraphics = this.add.graphics({
            lineStyle: { width: 2, color: 0x000000 },
            fillStyle: { color: 0x000000 }
        });
        bRect = new Phaser.Geom.Rectangle(0,0,400,600);
        left = bRect;
        bGraphics.fillRectShape(left);

        pathGraphics = this.add.graphics({
            lineStyle: { width: pathWidth, color: 0x66666 },
            fillStyle: { color: 0x66666 }
        });

        // Path
        path = new Phaser.Curves.Path();

        path.add( new Phaser.Curves.Line([ 32, 600, 32, 100 ]) );
        path.ellipseTo(50, 50, 180, 270, false, 0);
        path.lineTo(220, 50);
        path.ellipseTo(50, 50, 270, 0, false, 0);
        path.lineTo(270, 150);
        path.ellipseTo(50, 50, 180, 90, true, 0);
        path.lineTo(400, 200);
        path.lineTo(700, 300);
        path.lineTo(700, 600);

        // Follower
        // using physics group
        stars = this.physics.add.group({ allowGravity: false });

        for(var i = 0; i < 20; i++ ) {
            var pf = new PathFollower(this, 0, 0, path, 0.003)
            pf.setActive(false)
            pf.setVisible(false)
            stars.add(pf, true);
        }

        // Towers
        towers = new Towers(this);

        bullets = new Bullets(this);

        this.physics.add.overlap(bullets, stars, hit, null, this);
    }

    function update ()
    {
        // redraw path
        pathGraphics.clear()
        path.draw(pathGraphics);

        pathGraphics.fillCircle(mouseX, mouseY, 12);

        //  if stars reached path goal
        if( Phaser.Math.RND.integerInRange(0, 30) == 0 )
        {
            var dead = stars.getFirstDead(false);
            if(dead) {
                dead.setVisible(true);
                dead.setActive(true);
            }
        }
    }

    function hit(bullet, star) {
        bullet.hit()

        star.hit()
    }

    var config = {
        type: Phaser.AUTO,
        width: 800,
        height: 600,
        backgroundColor: '#808080',
        physics: {
            default: 'arcade',
            arcade: {
                gravity: { y: 0 }
            }
        },
        scene: {
            preload: preload,
            create: create,
            update: update
        }
    };

    var game = new Phaser.Game(config);
</script>

</body>
</html>
